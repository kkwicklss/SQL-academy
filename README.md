# SQL-academy
Мои решенные задачи с сайта sql-academy, а также некоторые выжимки из учебного материала
___ 
Выведите имена first_name и фамилии last_name студентов из таблицы Student, у кого отсутствует отчество middle_name
~~~~sql
SELECT first_name,
	last_name
FROM Student
WHERE middle_name IS NULL
~~~~
___
Выведите резервации комнат (поля room_id, start_date, end_date) из таблицы Reservations, у которых итоговая стоимость аренды (поле total) находится в промежутке от 500 до 1200 включительно.
~~~~sql
SELECT room_id,
	start_date,
	end_date
FROM Reservations
WHERE total BETWEEN 500 AND 1200
~~~~
___
Выведите информацию о студентах из таблицы Student, у которых год рождения соответствует одному из перечисленных: 2000, 2002 и 2004.
~~~~sql
SELECT *
FROM Student
WHERE year(birthday) IN (2000, 2002, 2004)
~~~~
___
Найдите все жилые помещения (таблица Rooms), в адресе которых содержится строка «Avenue». В результирующей выборке выведите поля id и address.
~~~~sql
SELECT id,
	address
FROM Rooms
WHERE address LIKE "%Avenue%"
~~~~
___
Выведите name, email пользователей, чей адрес электронной почты заканчивается на «@outlook.com» или «@live.com».
~~~~sql
SELECT name,
	email
FROM Users
WHERE email REGEXP "@(outlook.com|live.com)$"
~~~~
___
Для каждого отдельного платежа выведите идентификатор товара и сумму, потраченную на него, в отсортированном по убыванию этой суммы виде. Список платежей находится в таблице Payments. 
Для вывода суммы используйте псевдоним sum.
~~~~sql
SELECT good,
	amount * unit_price AS sum
FROM Payments
ORDER BY sum DESC;
~~~~
___
Выведите все данные членов семьи с фамилией Quincey из таблицы FamilyMembers и отсортируйте их по возрастанию сначала по столбцу status, а затем по member_name.
~~~~sql
SELECT *
FROM FamilyMembers
WHERE member_name LIKE "%Quincey"
ORDER BY STATUS,
	member_name;
~~~~
___
Подсчитайте количество учеников в каждом классе, а также отсортируйте их по убыванию количества учеников. Принадлежность ученика к конкретному классу вы можете получить из таблицы Student_in_class. В качестве результата необходимо вывести идентификатор класса (поле class) и количество учеников в этом классе.
Для вывода количества учеников используйте псевдоним count.
~~~~sql
SELECT class,
	COUNT(*) AS COUNT
FROM Student_in_class
GROUP BY class
ORDER BY COUNT DESC;
~~~~
___
Для каждого из существующих статусов (поле status) найдите самого старого человека (используйте поле birthday). Выведите статус и дату рождения.
Для вывода даты рождения используйте псевдоним birthday.
~~~~sql
SELECT STATUS,
	min(birthday) AS birthday
FROM FamilyMembers
GROUP BY STATUS;
~~~~
___
Получите среднее время полётов, совершённых на каждой из моделей самолёта. Выведите поле plane и среднее время полёта в секундах.
Для вывода времени используйте псевдоним time.
Используйте функцию TIMESTAMPDIFF(second, time_out, time_in), чтобы получить разницу во времени в секундах между двумя датами.
~~~~sql
SELECT plane,
	avg(timestampdiff(SECOND, time_out, time_in)) AS time
FROM Trip
GROUP BY plane;
~~~~
___
Выведите идентификатор комнаты (поле room_id), среднюю стоимость за один день аренды (поле price, для вывода используйте псевдоним avg_price), а также количество резерваций этой комнаты (используйте псевдоним count). Полученный результат отсортируйте в порядке убывания сначала по количеству резерваций, а потом по средней стоимости.
~~~~sql
SELECT room_id,
	AVG(price) AS avg_price,
	COUNT(*) AS COUNT
FROM Reservations
GROUP BY room_id
ORDER BY COUNT DESC,
	avg_price DESC;
~~~~
___
![alt text](https://github.com/kkwicklss/SQL-academy/blob/main/IMG_7544.webp)
Выведите типы комнат (поле home_type) и разницу между самым дорогим и самым дешевым представителем данного типа. В итоговую выборку включите только те типы жилья, количество которых в таблице Rooms больше или равно 2.
Для вывода разницы стоимости используйте псевдоним difference.
~~~~sql
SELECT home_type,
	max(price) - min(price) AS difference
FROM Rooms
GROUP BY home_type
HAVING COUNT(*) >= 2;
~~~~
___
Внутреннее соединение - соединение, при котором находятся пары записей из двух таблиц, удовлетворяющее условию соединения, тем самым образуя новую таблицу, содержащую поля из первой и второй исходных таблиц.
Объедините таблицы Class и Student_in_class с помощью внутреннего соединения по полям Class.id и Student_in_class.class. Выведите название класса (поле Class.name) и идентификатор ученика (поле Student_in_class.student).
~~~~sql
SELECT Class.name,
	Student_in_class.student
FROM Class
	JOIN Student_in_class ON Class.id = Student_in_class.class;
~~~~
___
Дополните запрос из предыдущего задания, добавив ещё одно внутреннее соединение с таблицей Student. Объедините по полям Student_in_class.student и Student.id и вместо идентификатора ученика выведите его имя (поле first_name).
~~~~sql
SELECT Class.name,
	first_name
FROM Class
	JOIN Student_in_class ON Class.id = Student_in_class.class
	JOIN Student ON Student_in_class.student = Student.id;
~~~~
___
Выведите названия продуктов, которые покупал член семьи со статусом "son". Для получения выборки вам нужно объединить таблицу Payments с таблицей FamilyMembers по полям family_member и member_id, а также с таблицей Goods по полям good и good_id.
~~~~sql
SELECT good_name
FROM Goods
	JOIN Payments ON Goods.good_id = Payments.good
	JOIN FamilyMembers ON Payments.family_member = FamilyMembers.member_id
WHERE STATUS = "son";
~~~~
___
Выведите идентификатор (поле room_id) и среднюю оценку комнаты (поле rating, для вывода используйте псевдоним avg_score), составленную на основании отзывов из таблицы Reviews.
Данная таблица связана с Reservations (таблица, где вы можете взять идентификатор комнаты) по полям reservation_id и Reservations.id.
~~~~sql
SELECT room_id,
	AVG(rating) AS avg_score
FROM Reservations
	JOIN Reviews ON Reservations.id = Reviews.reservation_id
GROUP BY room_id;
~~~~
___
Главным отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной ( LEFT , RIGHT ) или двух таблиц ( FULL ).
___
### Внешнее полное соединение
Соединение, которое выполняет внутреннее соединение записей и дополняет их левым внешним соединением
Алгоритм работы полного соединения:
* Формируется таблица на основе внутреннего соединения (INNER JOIN)
* В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN)
* В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN)
___
![alt text](https://github.com/kkwicklss/SQL-academy/blob/main/img.png)  
Выведите имя first_name и фамилию last_name каждого учителя из таблицы Teacher, а также количество занятий, в которых он был назначен преподавателем. Если преподаватель не был назначен ни на одно занятие, то выведите 0.
Для вывода количества занятий используйте псевдоним amount_classes.
~~~~sql
SELECT Teacher.first_name,
	Teacher.last_name,
	COUNT(Schedule.teacher) AS amount_classes
FROM Teacher
	LEFT JOIN Schedule ON Teacher.id = Schedule.teacher
GROUP BY Teacher.id;
~~~~
___
> Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.
Скалярный подзапрос - подзапрос, возвращающий одну строку и один столбец
___
Выведите всю информацию о пользователе из таблицы Users, кто является владельцем самого дорогого жилья (таблица Rooms).
~~~~sql
SELECT Users.*
FROM Users
	LEFT JOIN Rooms ON Users.id = Rooms.owner_id
WHERE price = (
		SELECT MAX(price)
		FROM Rooms
	);
~~~~
Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения, как это можно было делать со скалярными подзапросами.
Однако c подзапросами, возвращающими несколько строк и один столбец, можно использовать 3 дополнительных оператора. -> ALL, IN, ANY
Необходимо найти имена всех владельцев жилья, которые сами при этом никогда не снимали жилье. Чтобы получить данный список, мы можем действовать следующим образом:
Получить список имён всех владельцев жилья
~~~~sql
SELECT DISTINCT name FROM Users INNER JOIN Rooms
ON Users.id = Rooms.owner_id
~~~~
Получить список идентификаторов всех пользователей, снимавших жилье
~~~~sql
SELECT DISTINCT user_id FROM Reservations
~~~~
Отфильтровать первый список всех владельцев по условию, что идентификатор владельца жилья не равен ни одному из идентификаторов пользователей, когда-либо снимавших жилье
~~~~sql
SELECT DISTINCT name FROM Users INNER JOIN Rooms
    ON Users.id = Rooms.owner_id
    WHERE Users.id <> ALL (
        SELECT DISTINCT user_id FROM Reservations
    )
~~~~
~~~~sql
SELECT * FROM Users WHERE id IN (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
~~~~
~~~~sql
SELECT * FROM Users WHERE id = ANY (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
~~~~
___
Выведите названия товаров из таблицы Goods (поле good_name), которые ещё ни разу не покупались ни одним из членов семьи (таблица Payments).
~~~~sql
SELECT good_name
FROM Goods
WHERE Goods.good_id NOT IN (
		SELECT good
		FROM Payments
	);
~~~~
___
Выведите список комнат (все поля, таблица Rooms), которые по своим удобствам (has_tv, has_internet, has_kitchen, has_air_con) совпадают с комнатой с идентификатором "11".
~~~~sql
SELECT *
FROM Rooms
WHERE (
		Rooms.has_tv,
		Rooms.has_internet,
		Rooms.has_kitchen,
		Rooms.has_air_con
	) IN (
		SELECT Rooms.has_tv,
			Rooms.has_internet,
			Rooms.has_kitchen,
			Rooms.has_air_con
		FROM Rooms
		WHERE id = 11
	);
~~~~
___
С помощью коррелированного подзапроса выведите имена всех членов семьи (member_name) и цену их самого дорогого купленного товара.
Для вывода цены самого дорогого купленного товара используйте псевдоним good_price. Если такого товара нет, выведите NULL.
~~~~sql
SELECT member_name,
	(
		SELECT MAX(unit_price)
		FROM Payments
		WHERE Payments.family_member = FamilyMembers.member_id
	) AS good_price
FROM FamilyMembers;
~~~~
___
~~~~sql
-- Пример использования конструкции WITH
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")

SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;
~~~~
~~~~sql
WITH название_cte [(столбец_1 [, столбец_2 ] …)] AS (подзапрос)
    [, название_cte [(столбец_1 [, столбец_2 ] …)] AS (подзапрос)] …
~~~~
~~~~sql
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),
    Don_avia_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")

SELECT * FROM Don_avia_trips UNION SELECT * FROM  Aeroflot_trips;
~~~~
___
> Результаты выполнения SQL запросов можно объединять. Для этого существует оператор UNION.
~~~~sql
SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;
~~~~
UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.
* Не путайте операции объединения запросов с операциями объединения таблиц. Для этого служит оператор JOIN.
* Не путайте операции объединения запросов с подзапросами. Подзапросы выполняются для связанных таблиц.
  
Существует два других оператора, чьё поведение крайне схоже с UNION:
* INTERSECT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
* EXCEPT Комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.

Выведите полные имена (поля first_name, middle_name и last_name) всех студентов и преподавателей.
~~~~sql
SELECT Teacher.first_name,
	Teacher.middle_name,
	Teacher.last_name
FROM Teacher
UNION
SELECT Student.first_name,
	Student.middle_name,
	Student.last_name
FROM Student;
~~~~
___
Под условной логикой понимается наличие у программы нескольких путей выполнения в зависимости от каких-то условий.
Например, в базе данных «Расписание» есть таблица Student с полем birthday, отражающим дату рождения студента. Допустим, в выборке необходимо отобразить не саму дату рождения, а текстовое значение «Совершеннолетний» или «Несовершеннолетний» в зависимости от того, есть ли студенту 18 лет. Это и есть пример условной логики, при которой должно вывестись либо одно значение, либо другое в зависимости от конкретного условия.
~~~~sql
SELECT first_name, last_name,
CASE
  WHEN TIMESTAMPDIFF(YEAR, birthday, NOW()) >= 18 THEN "Совершеннолетний"
  ELSE "Несовершеннолетний"
END AS status
FROM Student
~~~~
~~~~sql
CASE
    WHEN условие_1 THEN возвращаемое_значение_1
    WHEN условие_2 THEN возвращаемое_значение_2
    WHEN условие_n THEN возвращаемое_значение_n
    [ELSE возвращаемое_значение_по_умолчанию]
END
~~~~
Если условие_1 возвращает истинное значение, то выражение CASE вернёт возвращаемое_значение_1, иначе будет сделана проверка на условие_2 и т.д. Если ни одно из предложенных условий не будет выполнено, то вернётся NULL или возвращаемое_значение_по_умолчанию, если была использована конструкция ELSE.
~~~~sql
SELECT name,
CASE
  WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (10, 11) THEN "Старшая школа"
  WHEN SUBSTRING(name, 1, INSTR(name, ' ')) IN (5, 6, 7, 8, 9) THEN "Средняя школа"
  ELSE "Начальная школа"
END AS stage
FROM Class
~~~~
___
Из таблицы Reviews выведите идентификаторы отзывов (поле id) и их категорию: для рейтинга 4-5 проставьте категорию «positive», для 3 проставьте «neutral», а для 1-2 - «negative».
Для вывода категории рейтинга используйте псевдоним rating.
~~~~sql
SELECT id,
    CASE
		WHEN rating IN (4, 5) THEN "positive"
		WHEN rating = 3 THEN "neutral"
		ELSE "negative"
	END AS rating
FROM Reviews;
~~~~
___
~~~~sql
SELECT id, price,
    IF(price >= 150, "Комфорт-класс", "Эконом-класс") AS category
    FROM Rooms
~~~~
~~~~sql
SELECT id, price,
    IF(price >= 200, "Бизнес-класс",
        IF(price >= 150,
            "Комфорт-класс", "Эконом-класс")) AS category
    FROM Rooms
~~~~
~~~~sql
IFNULL(значение, альтернативное_значение);
~~~~
~~~~sql
SELECT IFNULL("SQL Academy", "Альтернатива SQL Academy") AS sql_trainer;
~~~~
___
Из таблицы Rooms выведите идентификаторы сдаваемых жилых помещений (поле id) и наличие телевизора в помещении: если телевизор присутствует выведите «YES», иначе «NO». Для вывода наличия телевизора используйте псевдоним has_tv.
~~~~sql
SELECT id,
	IF(has_tv = 1, "YES", "NO") AS has_tv
FROM Rooms;
~~~~
___
Из таблицы Teacher выведите имена (поле first_name), отчества (поле middle_name) и фамилии (поле last_name) учителей. Если отчество у учителя отсутствует, выведите в поле middle_name значение «Empty».
~~~~sql
SELECT first_name,
	middle_name,
	last_name,
	IFNULL(middle_name, "Empty") AS middle_name
FROM Teacher;
~~~~
___
Для добавления новых записей в таблицу предназначен оператор INSERT.
~~~~sql
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ...
~~~~
___
Добавьте новый товар в таблицу Goods с именем «Table» и типом «equipment».
В качестве первичного ключа (good_id) укажите количество записей в таблице + 1.
~~~~sql
INSERT INTO Goods
SELECT COUNT(*) + 1,
	'Table',
	(
		SELECT good_type_id
		FROM GoodTypes
		WHERE good_type_name = 'equipment'
	)
FROM Goods;
~~~~
___
Для редактирования существующих записей в таблицах существует SQL оператор UPDATE.
~~~~sql
UPDATE имя_таблицы
SET поле_таблицы1 = значение_поля_таблицы1,
    поле_таблицыN = значение_поля_таблицыN
[WHERE условие_выборки]
~~~~
> Будьте внимательны, когда обновляете данные. Если вы пропустите оператор WHERE, то будут обновлены все записи в таблице.
В запросах на обновление данных можно менять значения, опираясь на предыдущее значение.
~~~~sql
UPDATE Payments
SET unit_price = unit_price * 2;
~~~~
___
Измените имя у "Wednesday Addams" на новое "Tuesday Addams".
~~~~sql
UPDATE FamilyMembers
SET member_name = "Tuesday Addams"
WHERE member_name = "Wednesday Addams";
~~~~
___
Обновите стоимость всех комнат в таблице (Rooms), добавив к текущей 10 единиц
~~~~sql
UPDATE Rooms
SET price = price + 10;
~~~~
___
Время от времени возникает задача удаления записей из таблицы. Для этого в SQL предусмотрены операторы DELETE и TRUNCATE, из которых наиболее универсальным и безопасным является первый вариант.
~~~~sql
DELETE FROM имя_таблицы
[WHERE условие_отбора_записей];
~~~~
Если условие отбора записей WHERE отсутствует, то будут удалены все записи указанной таблицы.
Эту же операцию (удаления всех записей) можно сделать также с помощью оператора TRUNCATE. Он выполнит удаление таблицы и пересоздаст её заново - этот вариант работает гораздо быстрее, чем удаление всех записей одна за другой (как в случае с DELETE) особенно для больших таблиц.
~~~~sql
TRUNCATE TABLE имя_таблицы;
~~~~
Если в DELETE запросе используется JOIN, то необходимо указать из каких(ой) именно таблиц(ы) требуется удалять записи.
~~~~sql
DELETE имя_таблицы_1 [, имя_таблицы_2] FROM
имя_таблицы_1 JOIN имя_таблицы_2
ON имя_таблицы_1.поле = имя_таблицы_2.поле
[WHERE условие_отбора_записей];
DELETE Reservations FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
~~~~
Если бы, помимо удаления бронирования, нам нужно было также удалить и жилье, то запрос приобрёл бы следующий вид:
~~~~sql
DELETE Reservations, Rooms FROM
Reservations JOIN Rooms ON
Reservations.room_id = Rooms.id
WHERE Rooms.has_kitchen = false;
~~~~
___
Удалите все записи из таблицы Payments, используя оператор DELETE.
~~~~sql
DELETE FROM Payments;
~~~~
___
Удалить запись из таблицы Goods, у которой поле good_name равно "milk"
~~~~sql
DELETE FROM Goods
WHERE good_name = 'milk';
~~~~
___
Измените запрос так, чтобы удалить товары (Goods), имеющие тип деликатесов (delicacies).
~~~~sql
DELETE Goods
FROM Goods
	JOIN GoodTypes ON Goods.type = GoodTypes.good_type_id
WHERE GoodTypes.good_type_name = "delicacies";
~~~~
___
## Продвинутый SQL
|  Имя функции  |  	        Описание	                 |
|---------------|------------------------------------------------|
|POW(num, power)|Вычисляет число в указанной степени             |
|SQRT(num)      |Вычисляет квадратный корень числа               |
|LOG(base, num) |Вычисляет логарифм числа по указанному основанию|
|EXP(num)       |Вычисляет e^num				 |
|SIN(num)       |Вычисляет синус числа				 |
|COS(num)       |Вычисляет косинус числа			 |
|TAN(num)       |Вычисляет тангенс числа			 |

Для округления числовых данных в SQL предусмотрены следующие 4 функции: CEIL, FLOOR, ROUND, TRUNCATE.

Функции CEIL, FLOOR направлены на то, чтобы округлять число к ближайшему целому числу в большую и в меньшую сторону соответственно.
~~~~sql
SELECT CEILING(69.69) AS ceiling, FLOOR(69.69) AS floor;
~~~~
Для округления к ближайшему целому числу есть функция ROUND, которая любое число, десятичная часть которого больше или равна 0.5, округляет в большую сторону, иначе в меньшую.
~~~~sql
SELECT ROUND(69.499), ROUND(69.5), ROUND(69.501);
~~~~
~~~~sql
SELECT ROUND(1691.7,-1), ROUND(1691.7,-2), ROUND(1691.7,-3);
~~~~
Функция TRUNCATE аналогична функции ROUND, она также способна принимать 2-й необязательный параметр, только вместо округления она просто отбрасывает ненужные цифры.
~~~~sql
SELECT TRUNCATE(69.7979,1), TRUNCATE(69.7979,2), TRUNCATE(69.7979,3);
~~~~
Функция SIGN возвращает значение -1, если число отрицательно, 0, если число нулевое и 1, если число положительное.
Функция ABS возвращает абсолютное значение числа
___
Выведите список цен всего доступного жилья (из таблицы Rooms), округлённых к ближайшему кратному 10-ти числу. Например, если цена равна "9676", то после округления она будет равна "9680".

Для вывода цены используйте псевдоним rounded_price.
~~~~sql
SELECT ROUND(price, -1) AS rounded_price
FROM Rooms;
~~~~
___
~~~~sql
SELECT  CAST("2022-06-16 16:37:23" AS DATETIME) AS datetime_1,
        CAST("2014/02/22 16*37*22" AS DATETIME) AS datetime_2,
        CAST("20220616163723" AS DATETIME) AS datetime_3,
        CAST("2021-02-12" AS DATE) AS date_1,
        CAST("160:23:13" AS TIME) AS time_1,
        CAST("89" AS YEAR) AS year

SELECT STR_TO_DATE('November 13, 1998', '%M %d, %Y') AS date;

SELECT CURDATE(), CURTIME(), NOW();
~~~~
___
|Тип|Формат по умолчанию|
|---|---|
|DATE|YYYY-MM-DD|
|DATETIME|YYYY-MM-DD hh:mm:ss|
|TIMESTAMP|YYYY-MM-DD hh:mm:ss|
|TIME|hhh:mm:sss|
|YEAR|YYYY - полный формат YY или Y - сокращённый формат, который возвращает год в пределах 2000-2069 для значений 0-69 и год в пределах 1970-1999 для значений 70-99|

|Критерий|DATETIME|TIMESTAMP|
|Диапазон|от 1000-01-01 00:00:00 до 9999-12-31 23:59:59|от 1970-01-01 00:00:00 до 2038-01-19 03:14:07|
|Часовой пояс|Не учитывается, Отображается в таком виде, в котором дата была установлена|Учитывается, При выборках отображается с учётом текущего часового пояса сервера БД|

### Определение возраста
~~~~sql
SELECT YEAR(NOW()) - YEAR('2003-07-03 14:10:26');
~~~~
Проблема такого подхода в том, что он не учитывает был ли день рождения у данного человека в этом году или ещё нет. То есть, если на момент запроса уже наступило 3-е июля (07-03), то человек отпраздновал свой день рождения и ему уже 20 лет, иначе ему по-прежнему 19 года. Разница функций YEAR тут будет бесполезна — в обоих случаях она даст 20 лет.
Если определить возраст через разницу годов — неработающий вариант, то может возникнуть желание найти возраст через разницу дней между двумя датами, затем поделить эту разницу на количество дней в году и округлить вниз:
~~~~sql
SELECT FLOOR(DATEDIFF(NOW(), '2003-07-03 14:10:26') / 365);
~~~~
И это решение будет гораздо точнее предыдущего. Но оно не будет абсолютно точным из-за наличия високосных годов, когда в году 366 дней. Хотя погрешность в вычислении возраста для 1 человека из-за наличия високосного года достаточно низкая, в вычислениях на определение, скажем, среднего возраста среди определённого списка людей, погрешность может накапливаться и исказить реальные значения.
И как же тогда корректно определять возраст? Для этого есть готовая встроенная функция — TIMESTAMPDIFF, которая первым аргументом принимает единицу измерения, в которой нужно вернуть разницу между двумя временными значениями.
~~~~sql
TIMESTAMPDIFF(YEAR, '2003-07-03 14:10:26', NOW());
~~~~
___
Пропишите формат строки во втором аргументе функции STR_TO_DATE, чтобы функция корректно отработала и вернула дату, на основании переданной первым аргументом строки.
~~~~sql
SELECT STR_TO_DATE('Date: 31 December 2023', 'Date: %d %M %Y') AS date
~~~~
___
Выведите имена (поле member_name) и возраст для каждого человека из таблицы FamilyMembers. 
Для вывода возраста используйте псевдоним age.
~~~~sql
SELECT member_name,
	TIMESTAMPDIFF(YEAR, birthday, NOW()) AS age
FROM FamilyMembers;
~~~~
___
CAST(значение AS тип_для_конвертации);
CONVERT(значение, тип_для_конвертации);
Функция CAST умеет конвертировать переданное значение в любой из следующих типов:
|Тип|Описание|
|---|---|
|DATE|Конвертирует значение в DATE. Формат: "YYYY-MM-DD".|
|DATETIME|Конвертирует значение в DATETIME. Формат: "YYYY-MM-DD hh:mm:ss".|
|TIME|Конвертирует значение в TIME. Формат: "hh:mm:ss".|
|DECIMAL[(M[,D])]|Конвертирует значение в DECIMAL. Имеет два необязательных аргумента M и D, определяющих максимальное количество знаков до и после запятой соответственно. По умолчанию, D равен 0, а M равен 10.|
|CHAR[(N)]|Конвертирует значение в CHAR. В качестве необязательного аргумента можно передать максимальную длину строки.|
|SIGNED|Конвертирует значение в значение BIGINT.|
|UNSIGNED|Конвертирует значение в беззнаковое значение BIGINT.|
|BINARY|Конвертирует значение в BINARY.|
|YEAR|Конвертирует значение в год.|

### Оконные функции
Оконные функции — мощный инструмент языка SQL, позволяющий проводить сложные вычисления по группам строк, которые связаны с текущей строкой.
Когда применяются оконные функции, запрос сегментируется на группы строк (или «окна»), и для каждого такого сегмента подсчитываются индивидуальные агрегатные значения.
Это окно, которое подаётся в оконную функцию, может быть:
* всей таблицей
* отдельными партициями таблицы, то есть группой строк на основе одного или нескольких полей
* или даже конкретным диапазоном строк в пределах таблицы или партиции. Например, мы можем определить окно, которое будет передаваться в оконную функцию, как предыдущая + текущая строка таблицы. И тогда для каждой строки значение агрегатной функции будет подсчитываться по-своему, так как данные, которые поступают в функцию будут динамически меняться от строке к строке. Окно будет как бы «скользить» по таблице.

~~~~sql
SELECT <оконная_функция>(<поле_таблицы>)
OVER (
      [PARTITION BY <столбцы_для_разделения>]
      [ORDER BY <столбцы_для_сортировки>]
      [ROWS|RANGE <определение_диапазона_строк>]
)
~~~~
~~~~sql
SELECT
    Student.first_name,
    Student.last_name,
    Student_in_class.class,
    COUNT(*) OVER (PARTITION BY Student_in_class.class) AS student_count_in_class
FROM
    Student_in_class
JOIN
    Student ON Student_in_class.student = Student.id;
~~~~
Оконные функции предоставляют расчёты для каждой строки, учитывая набор строк (окно), связанный с текущей строкой, в то время как агрегатные функции с группировкой предоставляют один результат для каждой группы, созданной по критерию группировки.
### Партиции в оконных функциях
Партиции — подмножества строк, выделенные для оконной функции на основе одного или нескольких столбцов в таблице.
Они служат для сегментации данных, позволяя выполнить более детальный анализ и расчёты вроде агрегации или ранжирования внутри каждой такой группы.
Для того, чтобы использовать партицию вместе с оконной функцией необходимо придерживаться следующего синтаксиса:
~~~~sql
SELECT <оконная_функция>(<поле_таблицы>)
OVER (
    PARTITION BY <столбцы_для_разделения>
)
~~~~
___
Из таблицы Rooms вывести поля home_type и price, а также добавить колонку min_price_by_type, в которой необходимо вывести минимальную стоимость жилья для текущего типа жилья (home_type). Для вычисления минимальной стоимости нужно использовать оконную функцию MIN.
~~~~sql
SELECT home_type,
	price,
	MIN(price) OVER (PARTITION BY home_type) AS min_price_by_type
FROM Rooms;
~~~~
___
### Сортировка внутри окна
Сортировка в оконных функциях SQL — ключ к расширенному анализу данных. Она позволяет упорядочивать данные внутри определённой группы или окна, обеспечивая более точные и нацеленные агрегатные вычисления. Это особенно полезно при работе с временными рядами, где важен порядок событий, или при ранжировании данных внутри групп.
~~~~sql
SELECT user_id,
       start_date,
       total AS reservation_price,
       SUM(total) OVER (
            PARTITION BY user_id
       ) AS total_expenses
FROM Reservations;
~~~~
В результате выполненного запроса в колонке total_expenses вывелась общая сумма затраченных средств с разбивкой по пользователям. Но это не совсем то, что мы хотим: данные в таблице не упорядочены по дате и мы не видим как общие расходы росли со временем, мы видим только финальные расходы.
~~~~sql
SELECT user_id,
       start_date,
       total AS reservation_price,
       SUM(total) OVER (
           PARTITION BY user_id
           ORDER BY start_date
       ) AS cumulative_total
FROM Reservations;
~~~~
* Партиция (PARTITION BY). Это деление всего набора результатов на непересекающиеся подмножества, где каждое подмножество содержит строки с одинаковыми значениями в одном или нескольких столбцах. Оконные функции применяются отдельно к каждой партиции, как если бы каждая из них была отдельным набором данных.
* Окно. Определяет, какие конкретные строки в каждой партиции будут использоваться для вычисления оконной функции для каждой строки. Окно может изменяться от строки к строке.

Используя синтаксис ROWS или RANGE мы можем определить какое именно окно с данными будет передаваться в оконную функцию для вычисления значения для текущей строки.
Синтаксис определения границ окна выглядит как указание диапазона относительно текущей строки.
~~~~sql
SELECT <оконная_функция>(<поле_таблицы>)
OVER (
      ...
      ROWS|RANGE BETWEEN <начало границы окна> AND <конец границы окна>
)
~~~~
Например, если мы хотим, чтобы в оконную функцию при вычислениях попадали только две предыдущие записи и текущая строка, то синтаксис будет выглядеть следующим образом:
~~~~sql
... ROWS|RANGE BETWEEN 2 PRECEDING AND CURRENT ROW
~~~~
Если мы хотим, чтобы в оконную функцию передавались текущая строка и все последующие, то синтаксис будет выглядеть так:
~~~~sql
... ROWS|RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
~~~~
#### Возможные определения границ окна
* UNBOUNDED PRECEDING, все строки, предшествующие текущей
* N PRECEDING, N строк до текущей строки
* CURRENT ROW, текущая строка
* N FOLLOWING, N строк после текущей строки
* UNBOUNDED FOLLOWING, все последующие строки

#### ROWS
Основан на физических строках:
При использовании ROWS, определение окна основывается на физическом положении строк относительно текущей строки. Например, 1 PRECEDING означает одну строку до текущей.
Точная граница:
Определение окна с помощью ROWS чётко ограничивает количество строк, которые включаются в окно, делая его предсказуемым и конкретным.
#### RANGE
Основан на значениях:
RANGE, в отличие от ROWS, определяет границы окна на основе значений столбцов, упорядоченных в соответствии с ORDER BY в оконной функции.
Динамичность границ:
Границы, определённые с помощью RANGE, могут варьироваться в зависимости от данных, что делает окно гибким, но потенциально менее предсказуемым.
![alt text](https://sql-academy.org/_next/image?url=%2Fstatic%2FguidePage%2Ftypes-of-windows-functions%2Fcategories_of_windows_functions.png&w=3840&q=50)
~~~~sql
SELECT id,
	home_type,
	price,
	SUM(price) OVER(PARTITION BY home_type) AS 'Sum',
	COUNT(price) OVER(PARTITION BY home_type) AS 'Count',
	AVG(price) OVER(PARTITION BY home_type) AS 'Avg',
	MAX(price) OVER(PARTITION BY home_type) AS 'Max',
	MIN(price) OVER(PARTITION BY home_type) AS 'Min'
FROM Rooms;
~~~~
Ранжирующие оконные функции — это функции, которые ранжируют значение для каждой строки в окне.
~~~~sql
SELECT id,
	home_type,
	price,
	ROW_NUMBER() OVER(PARTITION BY home_type ORDER BY price) AS 'row_number',
	RANK() OVER(PARTITION BY home_type ORDER BY price) AS 'rank',
	DENSE_RANK() OVER(PARTITION BY home_type ORDER BY price) AS 'dense_rank'
FROM Rooms;
~~~~
Оконные функции смещения — это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна.
~~~~sql
SELECT id,
	home_type,
	price,
	LAG(price) OVER(PARTITION BY home_type ORDER BY price) AS 'lag',
	LAG(price, 2) OVER(PARTITION BY home_type ORDER BY price) AS 'lag_2',
	LEAD(price) OVER(PARTITION BY home_type ORDER BY price) AS 'lead',
	FIRST_VALUE(price) OVER(PARTITION BY home_type ORDER BY price) AS 'first_value',
	LAST_VALUE(price) OVER(PARTITION BY home_type ORDER BY price) AS 'last_value'
FROM Rooms;
~~~~
___
Из таблицы Rooms вывести id, home_type и price у всех жилых помещений, а также в отдельной колонке room_rank вывести ранг данного жилого помещения в его категории (home_type) по цене, используя для этого функцию DENSE_RANK так, чтобы самое дешёвое жилое помещение имело ранг 1, следующие за ним по цене — 2 и так далее.
~~~~sql
SELECT id,
	home_type,
	price,
	DENSE_RANK() OVER(PARTITION BY home_type ORDER BY price) AS room_rank
FROM Rooms;
~~~~
___
Дополните запрос так, чтобы найти разницу во времени между вылетами среди рейсов одной компании. 
В качестве результирующей выборки выведите идентификаторы компаний (в поле company), время вылета их рейсов (в поле time_out) и время (в поле time_diff), прошедшее с предыдущего вылета в формате ЧЧ-MM-СС. Если это был первый рейс компании, то в поле time_diff нужно вывести "00:00:00".
~~~~sql
SELECT company,
	time_out,
	TIMEDIFF(
		time_out,
		FIRST_VALUE(time_out) OVER (
			PARTITION BY company
			ORDER BY time_out ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
		)
	) AS time_diff
FROM Trip;
~~~~
___
> Транзакция — это последовательность операций с базой данных, которые выполняются как единое целое.

Блокировка — это метод ограничения доступа к данным для обеспечения корректной обработки транзакций.
Существует ряд различных стратегий, которые могут использоваться, как именно блокировать ресурс. Сервер может применять блокировку на одном из трёх разных уровней, или гранулярностей.
* Блокировка таблиц: Не позволяет нескольким пользователям одновременно изменять данные в одной таблице.
* Блокировка страниц: Не позволяет нескольким пользователям изменять данные в одной и той же странице (страница — это сегмент памяти, обычно в диапазоне от 2 до 16 Кбайт) таблицы одновременно.
* Блокировка строк: Не позволяет нескольким пользователям одновременно изменять одну и ту же строку в таблице.

Основная цель блокировки в базах данных — предотвращение конфликтов доступа и обеспечение целостности данных путем временного блокирования доступа к ним.
Если вы попытаетесь перевести 1000 долларов с вашего сберегательного счёта на текущий и вдруг обнаружите, что деньги были списаны, но не зачислены на текущий счёт, вы, скорее всего, расстроитесь. 😿
Для защиты от такого рода ошибок программа, обрабатывающая ваш запрос на перевод денег, сначала начинает транзакцию, затем запускает SQL-запросы, необходимые для перевода денег с одного счёта на другой, и, если все проходит успешно, завершает транзакцию, выполнив команду COMMIT — фиксации изменений.
Однако, если возникнут какие-либо проблемы, будет выполнена команда ROLLBACK, которая указывает серверу отменить все действия, совершённые с начала транзакции.
Процесс может выглядеть следующим образом:
~~~~sql
-- Начало транзакции
START TRANSACTION;

-- Проверка наличия достаточного баланса у отправителя
SELECT @balance := user_balance FROM accounts WHERE user_id = 1;

-- Если средств недостаточно, отмена транзакции
IF @balance < 1000 THEN
ROLLBACK;
END IF;

-- Проверка на существование получателя
SELECT @exists := COUNT(*) FROM accounts WHERE user_id = 2;
IF @exists = 0 THEN
ROLLBACK;
END IF;

-- Обновление баланса счетов, если все проверки пройдены
UPDATE accounts SET user_balance = user_balance - 1000 WHERE user_id = 1;
UPDATE accounts SET user_balance = user_balance + 1000 WHERE user_id = 2;

-- Применение изменений
COMMIT;
~~~~
С помощью транзакции программа обеспечивает сохранность ваших 1000 долларов, гарантируя, что они либо останутся на исходном счёте, либо будут переведены на другой счёт, исключая риск их утраты.
Каждая явная транзакция в MySQL начинается с использования оператора START TRANSACTION.
Завершение же транзакции возможно:
* с помощью команды COMMIT, которая даёт указание серверу пометить изменения как постоянные и освободить все ресурсы (т.е. блокировки строк), использовавшиеся во время транзакции
* с помощью команды ROLLBACK, которая требует от сервера вернуть данные в состояние до начала транзакции. После завершения отката также любые ресурсы, используемые транзакцией, освобождаются.

Помимо использования команд COMMIT и ROLLBACK, транзакция также может завершиться в результате внешних факторов. Например, если сервер выключается, в этом случае ваша транзакция будет автоматически отменена при перезапуске сервера.
В определённых ситуациях вам может потребоваться выполнить откат в транзакции, не отменяя всю проделанную работу. Для этого вы можете установить одну или несколько точек сохранения в рамках транзакции. Это позволяет вам откатиться к конкретной точке в транзакции, а не к её началу.
Каждой точке сохранения в рамках одной транзакции необходимо присвоить уникальное имя, что позволит использовать множество разных точек сохранения. Для создания точки сохранения под названием my_savepoint используйте следующую команду:
~~~~sql
SAVEPOINT my_savepoint;
~~~~
Для отката к определённой точке сохранения просто вводится команда ROLLBACK, за которой следуют ключевые слова TO SAVEPOINT и имя точки сохранения, например:
~~~~sql
START TRANSACTION;

-- Создаем точку сохранения перед изменением баланса первого пользователя
SAVEPOINT before_updating_user_1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;

-- Проверка условия для первого пользователя
-- например, проверяем логику бизнес-правил

-- Здесь мы предполагаем, что условие не выполнилось, и нам нужно отменить изменение баланса
ROLLBACK TO SAVEPOINT before_updating_user_1;

-- Обновляем баланс для второго пользователя
UPDATE accounts SET balance = balance + 200 WHERE user_id = 2;

-- Завершаем транзакцию
COMMIT;
~~~~
В результате этой транзакции баланс первого пользователя останется без изменений из-за отката к точке сохранения, а баланс второго пользователя увеличится на 200. Это показывает, как можно управлять изменениями в базе данных с высоким уровнем контроля при помощи транзакций и точек сохранения.
Когда вы используете точки сохранения, помните следующие моменты:
* Несмотря на название, при создании точки сохранения ничего не сохраняется. Чтобы ваши изменения в рамках транзакции стали постоянными, необходимо выполнить команду COMMIT.
* При выполнении отката транзакции без указания конкретной точки сохранения, все ранее установленные точки сохранения будут проигнорированы, и будет произведён откат всей транзакции.

### Создание и удаление баз данных
Создание базы данных имеет следующий синтаксис:
~~~~sql
CREATE DATABASE имя_базы_данных;
~~~~
В качестве имени для базы данных можно использовать сочетания букв, цифр, а также символов "_" и "$". Имя может начинаться с цифр, но не может состоять только из них. Максимальная длина имени составляет 64 знака.
Проконтролировать создание базы данных можно с помощью оператора SHOW DATABASES.
~~~~sql
SHOW DATABASES;
~~~~
> Обратите внимание, что оператор SHOW DATABASES кроме пользовательских баз данных отображает также и служебные: information_schema, mysql, performance_schema, sys.

Удаление базы данных осуществляется с помощью оператора DROP DATABASE:
~~~~sql
DROP DATABASE имя_базы_данных;
~~~~
При создании базы данных или при её удалении может возникнуть ошибка, что база данных с таким именем уже существует (при создании) или, наоборот, данной базы данных не существует (при удалении). Для таких случаев существует конструкция IF [NOT] EXIST.
То есть, если мы хотим создать базу данных только при условии, что она пока не существует, то используется следующий синтаксис:
~~~~sql
CREATE DATABASE IF NOT EXIST имя_базы_данных;
~~~~
Если мы хотим удалить базу данных только при условии, что она существует, то используется следующий синтаксис:
~~~~sql
DROP DATABASE IF EXIST имя_базы_данных;
~~~~
Перед созданием таблицы необходимо выбрать базу данных, в которую таблица будет записана. Это делается с помощью оператора USE:
~~~~sql
USE имя_базы_данных;
~~~~
Для создания таблицы используется оператор CREATE TABLE. Его базовый синтаксис имеет следующий вид:
~~~~sql
CREATE TABLE [IF NOT EXIST] имя_таблицы (
     столбец_1 тип_данных,
    [столбец_2 тип_данных,]
    ...
    [столбец_n тип_данных,]
);
~~~~
Например, создадим таблицу пользователей.
~~~~sql
CREATE TABLE Users (
    id INT,
    name VARCHAR(255),
    age INT
);
~~~~
INT, VARCHAR(255) - типы данных: числовой и строковый соответственно. Более подробно о них можно будет узнать в следующих статьях.
Вышеприведённое определение столбцов в таблице является упрощённым. Помимо названия столбца и его типа в определение иногда необходимо добавлять следующие необязательные параметры:
* PRIMARY KEY
Указывает колонку или множество колонок как первичный ключ.
* AUTO_INCREMENT
Указывает, что значение данной колонки будет автоматически увеличиваться при добавлении новых записей в таблицу. Каждая таблица имеет максимум одну AUTO_INCREMENT колонку. Стоит отметить, что данный параметр можно применять только к целочисленным типам и к типам с плавающей запятой.
* UNIQUE
Указывает, что значения в данной колонке для всех записей должны быть отличными друг от друга.
* NOT NULL
Указывает, что значения в данной колонке должны быть отличными от NULL.
* DEFAULT
Указывает значение по умолчанию. Данный параметр не применяется к типам BLOB, TEXT, GEOMETRY и JSON.

Для нашей таблицы пользователей можно указать следующие параметры:
~~~~sql
CREATE TABLE Users (
    id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18
);
~~~~
Так, в данном примере:
* id - поле числового типа, являющееся первичным ключом;
* name - поле строкового типа с максимальной длиной в 255 символов, являющееся обязательным к заполнению;
* age - поле числового типа со значением по умолчанию равным 18.

Для того, чтобы посмотреть описание созданной таблицы можно воспользоваться оператором DESCRIBE.
~~~~sql
DESCRIBE Users;
~~~~
Помимо описания столбцов, при создании таблицы можно дополнительно указать следующие параметры:
* Первичный ключ.
Если вы не определили первичный ключ с помощью параметров столбца, то это можно сделать с помощью дополнительных параметров таблицы, добавив запись PRIMARY KEY (<столбец_1>, <столбец_n>) после перечисления столбцов:
~~~~sql
CREATE TABLE Users (
    id INT,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18,
    PRIMARY KEY (id)
);
~~~~
* Внешние ключи.
Предположим, что мы хотим хранить данные о компании, в которой работают наши пользователи. Давайте создадим небольшую таблицу Companies, в которой мы будем хранить уникальный идентификатор и название компании:
~~~~sql
CREATE TABLE Companies (
    id INT,
    name VARCHAR(255) NOT NULL,
    PRIMARY KEY (id)
);
~~~~
Дальше нужно добавить в таблицу Users поле company – место работы нашего пользователя, которое будет ссылаться на запись в таблице Companies. Полный запрос для создания таблицы будет выглядеть так:
~~~~sql
CREATE TABLE Users (
    id INT,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18,
    company INT,
    PRIMARY KEY (id)
);
~~~~
Для того, чтобы при добавлении новых записей в таблицу Users гарантировать, что в колонке company находится идентификатор, существующий в таблице Companies, используется внешний ключ. Он имеет следующий синтаксис:
~~~~sql
FOREIGN KEY (<столбец_1>, <столбец_n>)
REFERENCES <внешняя_таблица> (<столбец_во_внешней_таблице_1>, <столбец_во_внешней_таблице_n>)
[ON DELETE действие]
[ON UPDATE действие]
~~~~
Полный запрос для создания таблицы с внешним ключом будет таким:
~~~~sql
CREATE TABLE Users (
    id INT,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18,
    company INT,
    PRIMARY KEY (id),
    FOREIGN KEY (company) REFERENCES Companies (id)
);
~~~~
При наличии внешних ключей можно определить поведение текущей записи, при изменении или удалении записи, на которую она ссылается.
~~~~sql
CREATE TABLE Users (
    id INT,
    name VARCHAR(255) NOT NULL,
    age INT NOT NULL DEFAULT 18,
    company INT,
    PRIMARY KEY (id),
    FOREIGN KEY (company) REFERENCES Companies (id)
    ON DELETE RESTRICT ON UPDATE CASCADE
);
~~~~
ON DELETE RESTRICT означает, что если попробовать удалить компанию, у которой в таблице Users есть данные, база данных не даст этого сделать:
~~~~sql
Cannot delete or update a parent row: a foreign key constraint fails
~~~~
Если бы было указано ON DELETE CASCADE, то при удалении компании были бы удалены все пользователи, ссылающиеся на эту компанию.
Есть ещё одна опция — ON DELETE SET NULL. При её использовании база данных запишет NULL в качестве значения поля company для всех пользователей, работавших в удалённой компании.
ON UPDATE CASCADE означает, что если компания изменит свой идентификатор, то все пользователи (Users) получат новый идентификатор в поле company.
Удаление таблицы производится при помощи оператора DROP TABLE.
~~~~sql
DROP TABLE [IF EXIST] имя_таблицы;
~~~~
В SQL каждый столбец в таблице должен иметь определённый тип данных, указывающий на то, какая информация может храниться в этом столбце. Тип данных столбца определяет, какие операции можно выполнять с данными в этом столбце, сколько места требуется для хранения данных и как данные хранятся внутри.
В SQL есть несколько распространённых типов данных, в том числе:
* Строковый тип данных
* Числовой тип данных
* Булевый тип данных
* Дата и время

При определении таблицы в SQL важно выбрать соответствующие типы данных для каждого столбца, чтобы обеспечить эффективное хранение и извлечение данных. Кроме того, важно учитывать возможный диапазон значений, которые будут храниться в каждом столбце, и выбирать тип данных, соответствующий этому диапазону.
Строковый тип данных является наиболее используемым типом данных. Благодаря ему в базе данных хранятся как текстовые, так и различные двоичные данные (например, картинки).
В MySQL он представлен следующими типами:
|Тип|Описание|Диапазон символов|
|---|---|---|
|CHAR(X)|Содержит текстовые строки. Длина фиксируемая, её вы указываете при объявлении. В случае, если длина строки меньше указанной, она дополняется правыми пробелами до указанной длины.|Длина может быть любой в диапазоне от 0 до 255|
|VARCHAR(X)|Содержит текстовые строки. Длина строк динамическая.|Длина может быть любой в диапазоне от 0 до 65,535|

Типы данных BINARY и VARBINARY аналогичны VARCHAR и CHAR только они хранят двоичные строки.
|Тип|Описание|Диапазон символов|
|---|---|---|
|BINARY(X)|Содержит двоичные строки. Длина фиксируемая, её вы указываете при объявлении.|Длина может быть любой в диапазоне от 0 до 255|
|VARBINARY(X)|Содержит двоичные строки. Длина строк динамическая.|Длина может быть любой в диапазоне от 0 до 65,535|

BLOB используется для хранения больших бинарных данных, таких как картинки. TEXT предназначен также для хранения больших данных, но текстового содержания.
Разница между ними заключается в том, что сортировки и сравнения сохранённых данных у BLOB чувствительны к регистру и не чувствительны к регистру в полях TEXT.
|Тип|Описание|Диапазон символов|
|---|---|---|
|BLOB|Содержит двоичные строки.|Максимальная длина 65,535|
|TEXT|Содержит текстовые строки.|Максимальная длина 65,535|

BLOB и TEXT имеют дополнительные подтипы, которые отличаются максимальным размером данных, которые можно в них хранить.
|Тип|Диапазон символов|
|---|---|
|TINYBLOB|Максимальная длина 255|
|MEDIUMBLOB|Максимальная длина 16,777,215|
|LONGBLOB|Максимальная длина 4,294,967,295|
|TINYTEXT|Максимальная длина 255|
|MEDIUMTEXT|Максимальная длина 16,777,215|
|LONGTEXT|Максимальная длина 4,294,967,295|

Числовые данные разделяются на точные и приближенные, на целые и вещественные. В отдельную категорию можно отнести битовые значения.
|Тип|Объем памяти|Диапазон|
|---|---|---|
|TINYINT|1 байт|от -128 до 127 (от -2^7 до 2^7 -1) от 0 до 255 (от 0 до 2^8 -1)|
|SMALLINT|2 байта|от -32768 до 32767 (от -2^15 до 2^15 -1) от 0 до 65535 (от 0 до 2^16 -1)|
|MEDIUMINT|3 байта|от -2^23 до 2^23 -1 от 0 до 2^24 -1|
|INT INTEGER (синонимы)|4 байта|от -2^31 до 2^31 -1 от 0 до 2^32 -1|
|BIGINT|8 байт|от -2^63 до 2^63 -1 от 0 до 2^64 -1|
Целые числа могут быть объявлены с ключевым словом UNSIGNED. В этом случае элементам данного столбца нельзя будет присвоить отрицательные значения, а допустимый диапазон, которые принимает тип удваивается. Так, тип TINYINT может принимать значения от -128 до 127, а TINYINT UNSIGNED — от 0 до 255.

|Тип|Диапазон|
|---|---|
|DEC[(M,D)] DECIMAL[(M,D)] (синонимы)|Зависит от параметров M и D|

Тип DECIMAL хранит точное вещественное значение данных. Он используется, когда точность является критически важной. Например, при хранении финансовых данных.

Пример использования:
~~~~sql
CREATE TABLE Users (
    ...
    salary DECIMAL(5,2)
);
~~~~
В данном примере объявляется, что в колонке salary будут храниться числа, имеющие максимум 5 цифр, причём 2 из которых отведены под десятичную часть. То есть, в данной колонке будут храниться значения в промежутке от -999.99 до 999.99.
Синтаксис DECIMAL эквивалентен DECIMAL(M) и DECIMAL(M,0). По умолчанию, параметр M равен 10.
Целая часть и часть после точки хранятся как 2 отдельных целых числа. На основании этого факта можно легко рассчитать затрачиваемый объем памяти. Так у DECIMAL(5,2) целая часть содержит 3 цифры и занимает 2 байта, часть после точки 2 цифры - достаточно 1 байта. Итого, на хранение будет потрачено 3 байта.

|Тип|Объем памяти|Диапазон|
|---|---|---|
|BIT[(M)]|M бит|От 1 до 64 битов, в зависимости от значения M|
|BOOL BOOLEAN (синонимы)|1 бит|Либо 0, либо 1|

Тип данных BIT(M) хранит последовательность битов заданной длины. По умолчанию, длина составляет 8 бит. Если назначаемое значение в колонке с данным типом использует меньше M бит, то происходит дополнение нулями слева. Например, при попытке записать значение b'101' в BIT(6) храниться в итоге будет b'000101'.

|Тип|Объем памяти|Диапазон|
|---|---|---|
|FLOAT[(M, D)]|4 байта|Минимальное значение ±1.17·10^-39 Максимальное значение ±3.4·10^38|
|REAL[(M, D)] DOUBLE[(M, D)] (синонимы)|8 байтов|Минимальное значение ±2.22·10^-308 Максимальное значение ±1.79·10^308|

Числовые типы данных с плавающей точкой также могут иметь параметр UNSIGNED. Как и в целочисленных типах, этот атрибут предотвращает хранение в отмеченном столбце отрицательных величин, но, в отличие от целочисленных типов, максимальный интервал для величин столбца остаётся прежним.

Для работы с датой и временем в MySQL есть несколько типов данных: DATE, TIME, DATETIME и TIMESTAMP.
Типы данных DATETIME и TIMESTAMP в MySQL похожи друг на друга, так как оба направлены на хранение даты и времени. Но между ними есть ряд существенных отличий, определяющих какой из этих типов данных когда лучше использовать.
ранит значения в диапазоне от 1000-01-01 00:00:00 до 9999-12-31 23:59:59 и при этом занимает 8 байт. Этот тип данных не зависит от временной зоны, установленной в MySQL. Он всегда отображается ровно в таком виде, в котором был установлен и в котором хранится в базе данных. То есть при изменении часового пояса, отображение времени не изменится.
~~~~sql
CREATE TABLE datetime_table (datetime_field DATETIME);
SET @@session.time_zone="+00:00"; -- сбрасываем часовой пояс в MYSQL
INSERT INTO datetime_table VALUES("2022-06-16 16:37:23");
SET @@session.time_zone="+03:00"; -- меняем часовой пояс в MYSQL
SELECT * FROM datetime_table;
~~~~
Хранит сколько прошло секунд с 1970-01-01 00:00:00 по нулевому часовому поясу и занимает 4 байта. При выборках отображается с учётом текущего часового пояса. Часовой пояс можно задать в настройках операционной системы, где работает MySQL, в глобальных настройках MySQL или в конкретной сессии. В базе данных при создании записи с типом TIMESTAMP значение сохраняется по нулевому часовому поясу.
~~~~sql
CREATE TABLE timestamp_table (timestamp_field TIMESTAMP);
SET @@session.time_zone="+00:00"; -- сбрасываем часовой пояс в MYSQL
INSERT INTO timestamp_table VALUES("2022-06-16 16:37:23");
SET @@session.time_zone="+03:00"; -- меняем часовой пояс в MYSQL
SELECT * FROM timestamp_table;
~~~~
Также стоит помнить о существующем ограничении TIMESTAMP в диапазоне возможных значений от 1970-01-01 00:00:01 до 2038-01-19 03:14:07, что ограничивает его применение. Так, данный тип данных не подойдёт для хранения дат рождения пользователей.
Значения DATETIME, DATE и TIMESTAMP могут быть заданы одним из следующих способов:
* Как строка в формате YYYY-MM-DD HH:MM:SS или в формате YY-MM-DD HH:MM:SS для указания даты и времени
* Как строка в формате YYYY-MM-DD или в формате YY-MM-DD для указания только даты
При указании даты допускается использовать любой знак пунктуации в качестве разделительного между частями разделов даты или времени. Также возможно задавать дату вообще без разделительного знака, слитно.
~~~~sql
CREATE TABLE date_table (datetime TIMESTAMP);
INSERT INTO date_table VALUES("2022-06-16 16:37:23");
INSERT INTO date_table VALUES("22.05.31 8+15+04");
INSERT INTO date_table VALUES("2014/02/22 16*37*22");
INSERT INTO date_table VALUES("20220616163723");
INSERT INTO date_table VALUES("2021-02-12");
SELECT * FROM date_table;
~~~~
> Представление — объект базы данных, являющийся результатом выполнения запроса к базе данных, определённого с помощью оператора SELECT, в момент обращения к представлению.

Представления иногда называют «виртуальными таблицами». Это связано с тем, что представление для пользователя выглядит как таблица, но фактически не хранит данных, а извлекает их из других таблиц в момент обращения.
Если данные в основной таблице меняются, пользователь получает актуальные данные при обращении к представлению, использующему эту таблицу. При этом представления не кэшируют результаты выборки из таблицы в процессе работы.
~~~~sql
CREATE VIEW ViewUsers AS
    SELECT id,
           name,
           CONCAT(SUBSTR(email, 1, 2), '****', SUBSTR(email, -4)) AS email
FROM Users;
~~~~
~~~~sql
CREATE [OR REPLACE]
VIEW имя_представления [(имена_полей_представления)]
AS select_выражение
~~~~
OR REPLACE — при использовании этого опционального параметра в случае, если представление с таким именем уже существует, старое представление будет удалено, а новое создано. В противном случае, при попытке создать представление с существующим именем, возникнет ошибка.
___
На основании таблицы Student создайте представление ViewStudent, содержащие только поля id, first_name и last_name.
~~~~sql
CREATE VIEW ViewStudent AS
SELECT id,
	first_name,
	last_name
FROM Student;
~~~~
___
Когда вы добавляете в таблицу новую строку, СУБД размещает эти данные не оптимально. Например, если вы добавляете строку в таблицу Users, СУБД не размещает строки в числовом порядке значений столбца id или в алфавитном порядке значений столбца last_name. Вместо этого он просто помещает данные в следующее доступное место в файле (СУБД поддерживает список свободных мест для каждой таблицы).
~~~~sql
SELECT email FROM Users WHERE email LIKE 'l%';
~~~~
Серверу базы данных приходится проверять каждую строку таблицы, чтобы найти соответствия. Это подходит для маленьких таблиц, но становится чрезмерно времязатратным по мере роста объёма данных.
Возвращаясь к таблице Users, вы можете добавить индекс к столбцу email, чтобы ускорить любые запросы, которые работают со значением этого столбца.
Вот как можно добавить такой индекс в СУБД MySQL:
~~~~sql
CREATE INDEX idx_email
    ON Users (email);
~~~~
Эта инструкция создаёт индекс c именем idx_email для столбца Users.email. При наличии индекса оптимизатор запросов может выбрать использование индекса, если сочтёт это полезным. Если в таблице имеется более одного индекса, оптимизатор должен решить, применение какого именно индекса наиболее выгодно для конкретной инструкции SQL.
Все системы управления базами данных предоставляют возможность просмотра существующих индексов. Для пользователей MySQL существует команда SHOW, которая позволяет отобразить все индексы для конкретной таблицы, как показано в примере ниже:
~~~~sql
SHOW INDEX FROM Users;
~~~~
Вывод демонстрирует, что в таблице Users есть 2 индекса: один — для столбца id с именем PRIMARY и ещё один для столбца email, который мы только что определили.
Когда таблица была создана, MySQL автоматически сгенерировала индекс для столбца первичного ключа, которым в данном случае является id, и присвоил индексу имя PRIMARY. Это особый тип индекса, используемый с ограничением первичного ключа, которое гарантирует, что каждое значение в столбце или группе столбцов, назначенных в качестве первичного ключа таблицы, уникально и не может быть NULL.
Если после создания индекса вы решите, что он больше не нужен, можете удалить его следующим образом:
~~~~sql
DROP INDEX idx_email ON Users;
~~~~
При проектировании баз данных важно определить, для каких столбцов допускаются повторения значений, а для каких — нет.
Например, в таблице Users может быть несколько пользователей с одинаковыми именами, но идентификаторы и адреса электронных почт они должны иметь разные, чтобы была возможность их различать.
Добиться гарантируемой уникальности значений можно, создав уникальный индекс на столбец Users.email. Уникальный индекс выполняет две функции:
* он обеспечивает все преимущества стандартного индекса
* он предотвращает дублирование значений в индексируемом столбце
Система управления базой данных будет проверять уникальный индекс при попытке добавления или изменения данных в индексированном столбце, чтобы убедиться, что введённое значение не дублирует уже существующее в таблице.
Создание уникального индекса для столбца Users.email выполняется следующим образом:
~~~~sql
CREATE UNIQUE INDEX idx_email
    ON Users (email);
~~~~
При наличии индекса вы получите сообщение об ошибке, если попытаетесь добавить нового клиента с уже существующим адресом электронной почты:
~~~~sql
Error(1062) 23000: "Duplicate entry 'duplicate@gmail.com' for key 'users.idx_email'"
~~~~
Создание уникальных индексов для столбца или столбцов, определённых как первичный ключ, излишне, так как система управления базой данных автоматически обеспечивает уникальность значений первичного ключа. Впрочем, размещение нескольких уникальных индексов в одной таблице допустимо и может быть целесообразно, если вы видите в этом необходимость.
Помимо одностолбцовых индексов, существует возможность создавать индексы, включающие в себя несколько столбцов. К примеру, для поиска студентов по имени и фамилии можно создать совместный индекс по этим двум полям:
~~~~sql
CREATE INDEX idx_full_name
    ON Student (last_name, first_name);
~~~~
Такой индекс окажется полезным для запросов, где необходимы и имя, и фамилия, или только фамилия. Однако, для запросов, задающих только имя, он не принесёт пользы. Это аналогично поиску номера телефона по телефонному справочнику: если известны и имя, и фамилия, поиск упрощается благодаря упорядоченности справочника по фамилии, а затем по имени. Если же известно только имя, придётся перебирать все записи в поисках нужного человека.
При создании индексов, включающих несколько столбцов, важно продумать порядок столбцов в индексе, чтобы он был максимально эффективным. Однако для достижения нужной производительности запросов всегда можно создать несколько индексов с теми же столбцами, но разным порядком их следования.
Индексы часто применяются СУБД для эффективного поиска нужных строк в таблице, а затем для получения дополнительных данных из связанных таблиц по запросу пользователя. Возьмём для примера запрос:
~~~~sql
SELECT id, first_name, last_name
  FROM Student
  WHERE first_name LIKE 'A%' AND last_name LIKE 'L%'
~~~~
В ответ на такой запрос СУБД может выбрать один из нескольких подходов:
* Произвести полное сканирование всех строк таблицы.
* Воспользоваться индексом по столбцу last_name для поиска студентов с фамилией на «L», а затем проверить каждую из этих строк на соответствие имени, начинающегося на «A».
* Использовать составной индекс по last_name и first_name для непосредственного нахождения студентов, удовлетворяющих обоим критериям.

Последний метод представляется наиболее эффективным, так как позволяет найти все необходимые строки за один проход, избегая повторного обращения к таблице. Но как определить, какой из методов выберет оптимизатор запросов MySQL? Для этого можно использовать команду EXPLAIN, которая показывает, как СУБД планирует выполнить запрос, не запуская его фактически:
~~~~sql
EXPLAIN
  SELECT id, first_name, last_name
  FROM Student
  WHERE first_name LIKE 'A%'
  AND last_name LIKE 'L%';
~~~~
Анализируя результаты, можно увидеть, что в столбце possible_keys указаны потенциально применимые индексы idx_last_name или idx_full_name, а в столбце key указано, что выбран индекс idx_full_name.
Если индексы столь эффективны, возникает вопрос: почему бы просто не индексировать всё подряд? 🧐
Ответ кроется в том, что каждый индекс представляет собой таблицу (пусть и особый тип таблицы, но все же это таблица). Следовательно, каждый раз, когда строка добавляется в таблицу или удаляется из неё, должны быть изменены все индексы в этой таблице. При обновлении строки любые индексы для столбца (или столбцов), которые были затронуты, также должны быть изменены. Следовательно, чем больше у вас индексов, тем больше должна работать СУБД, чтобы поддерживать все объекты схемы в актуальном состоянии — что приводит к замедлению работы.
Более того, индексы занимают дополнительное место на диске и требуют внимательного управления со стороны администраторов баз данных. Поэтому оптимальным решением является создание индексов только тогда, когда это действительно необходимо. Если индекс нужен временно, например, для выполнения месячного отчёта, его можно добавить перед началом процедуры и удалить после её завершения.
В итоге, идеальный подход заключается в нахождении баланса: необходимо иметь достаточно индексов для эффективной работы, но не столько, чтобы это сказывалось на производительности. Если вы не уверены в нужном количестве индексов, начните с минимального их числа и добавляйте по мере необходимости.
